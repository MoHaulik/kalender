<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Calendar and To-Do List with Work Blocks</title>
    <style>
        /* Shared Styles */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e7eb 100%);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .view-container {
            flex: 1;
            display: none; /* Hidden by default */
            justify-content: flex-start;
            align-items: center;
            flex-direction: column;
            gap: 20px;
            position: relative;
            width: 100%;
            height: 100%;
            overflow-y: auto; /* Enable vertical scrolling */
        }

        .active-view {
            display: flex; /* Show the active view */
        }

        /* Calendar Styles */
        .calendar-container {
            position: relative;
            width: 80%;
            max-width: 600px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 20px;
            color: rgba(0, 0, 0, 0.8);
            overflow: hidden;
        }

        #header-calendar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px;
            box-sizing: border-box;
            position: relative;
        }

        #date-container-calendar {
            text-align: left;
        }

        #date-calendar, #day-name-calendar, #month-name-calendar {
            font-size: 24px;
            margin: 0;
            line-height: 1.2;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer; /* Indicate clickable elements */
        }

        #editor-calendar {
            width: 100%;
            border: none;
            outline: none;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin-top: 10px;
            box-sizing: border-box;
            font-size: 26px;
            background: transparent;
            color: inherit;
            padding: 10px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .clickable {
            cursor: pointer;
            transition: text-decoration 0.3s ease, color 0.3s ease;
        }

        .clickable:hover {
            text-decoration: underline;
        }

        .completed {
            text-decoration: line-through;
            color: gray;
            transition: text-decoration 0.3s ease, color 0.3s ease;
            animation: none; /* Stop any animation */
            text-shadow: none; /* Remove any text shadow */
        }

        /* Need to do items */
        .need-to-do {
            animation: glow 1s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
            }
            to {
                text-shadow: 0 0 20px rgba(255, 0, 0, 1);
            }
        }

        /* Avatar Box Styling */
        .avatar-box {
            position: relative;
            width: 80%;
            max-width: 600px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            display: flex;
            align-items: center;
            border-radius: 20px;
            gap: 15px;
            cursor: pointer;
        }

        .avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .text-bubble {
            position: relative;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 15px;
            border-radius: 15px;
            color: rgba(0, 0, 0, 0.8);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-shadow: 0 1px 5px rgba(0, 0, 0, 0.05);
            flex-grow: 1;
            transition: opacity 0.5s ease;
            opacity: 1;
        }

        .text-bubble.hidden {
            opacity: 0;
        }

        /* Fullscreen Button Styling */
        .fullscreen-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .fullscreen-button.visible {
            opacity: 1;
        }

        /* Fullscreen Button Icon */
        .fullscreen-button::before {
            content: "\26F6";
            font-size: 20px;
            color: black;
        }

        /* Timer Styles */
        .timer-container {
            position: relative;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .progress-ring {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .progress-ring circle {
            fill: none;
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 8;
        }

        .progress-ring .progress {
            stroke: rgba(255, 255, 255, 0.8);
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }

        .connecting-circle {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .knob {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.4));
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            position: absolute;
            top: calc(50% - 30px);
            left: calc(50% - 30px);
            transition: box-shadow 0.3s ease;
            z-index: 10;
        }

        .knob:hover {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .knob:active {
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.7);
        }

        .display {
            font-size: 48px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 5;
        }

        .mode-indicators {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        .mode-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transition: background 0.3s ease;
        }

        .mode-indicator.active {
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .mode-name {
            font-size: 24px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.3s ease;
            position: relative;
            z-index: 5;
        }

        /* Navigation Button Styles */
        .nav-button-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-button {
            width: 15px;
            height: 15px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .nav-button.active {
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .calendar-container, .avatar-box {
                width: 90%;
                padding: 15px;
            }

            #date-calendar, #day-name-calendar, #month-name-calendar {
                font-size: 20px;
            }

            #editor-calendar {
                font-size: 22px;
            }

            .text-bubble {
                font-size: 16px;
            }

            .fullscreen-button {
                width: 35px;
                height: 35px;
                top: 8px;
                right: 8px;
            }

            .fullscreen-button::before {
                font-size: 18px;
            }

            .timer-container {
                width: 250px;
                height: 250px;
            }

            .display {
                font-size: 36px;
            }

            .mode-name {
                font-size: 20px;
            }

            .knob {
                width: 50px;
                height: 50px;
                top: calc(50% - 25px);
                left: calc(50% - 25px);
            }

            .nav-button {
                width: 12px;
                height: 12px;
            }
        }

        /* Work Block Styles */
        #work-blocks-container {
            width: 100%;
            margin-top: 20px;
        }

        .work-block {
            position: relative;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 15px;
            overflow: hidden;
            transition: background 0.5s ease;
            background-size: 600% 600%;
            animation: soap-bubble 10s ease infinite;
        }

        .block-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            cursor: pointer; /* Indicate editable title */
        }

        .block-title[contenteditable]:focus {
            outline: 2px dashed #ccc;
            background-color: rgba(255, 255, 255, 0.2);
        }

        .block-tasks {
            font-size: 20px;
            min-height: 50px;
        }

        .work-block.completed .block-title {
            text-decoration: line-through;
            color: gray;
        }

        .work-block.completed {
            background: rgba(200, 200, 200, 0.5);
            animation: none;
        }

        .work-block[data-block-index="1"] {
            background: linear-gradient(270deg, #ff7f50, #87cefa, #da70d6);
        }

        .work-block[data-block-index="2"] {
            background: linear-gradient(270deg, #7fffd4, #ffe4e1, #f0e68c);
        }

        .work-block[data-block-index="3"] {
            background: linear-gradient(270deg, #dda0dd, #afeeee, #98fb98);
        }

        @keyframes soap-bubble {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }
    </style>
</head>
<body>
    <!-- Calendar View -->
    <div class="view-container active-view" id="calendar-view">
        <div class="calendar-container">
            <div id="header-calendar">
                <div id="date-container-calendar">
                    <div id="date-calendar"></div>
                    <div id="month-name-calendar"></div>
                </div>
                <div id="day-name-calendar"></div>
                <!-- Fullscreen Button -->
                <button class="fullscreen-button" id="fullscreen-btn-calendar" aria-label="Toggle Fullscreen"></button>
            </div>

            <!-- Editor and Work Blocks -->
            <div id="to-do-list-container">
                <div id="editor-calendar" contenteditable="true"></div>

                <!-- Work Blocks Container -->
                <div id="work-blocks-container">
                    <div class="work-block" data-block-index="1">
                        <div class="block-title" contenteditable="true">Work Block 1</div>
                        <div class="block-tasks" contenteditable="true"></div>
                    </div>
                    <div class="work-block" data-block-index="2">
                        <div class="block-title" contenteditable="true">Work Block 2</div>
                        <div class="block-tasks" contenteditable="true"></div>
                    </div>
                    <div class="work-block" data-block-index="3">
                        <div class="block-title" contenteditable="true">Work Block 3</div>
                        <div class="block-tasks" contenteditable="true"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Avatar Box for Calendar View -->
        <div class="avatar-box" onclick="openChat()">
            <div class="avatar">
                <img src="Avatar.jpeg" alt="Avatar">
            </div>
            <div class="text-bubble" id="greeting-message-calendar">
                <!-- Placeholder for text bubble content -->
            </div>
        </div>
    </div>

    <!-- Timer View -->
    <div class="view-container" id="timer-view">
        <div class="timer-container">
            <svg class="progress-ring" viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="45" />
                <circle class="progress" cx="50" cy="50" r="45" />
            </svg>
            <canvas class="connecting-circle" width="300" height="300"></canvas>
            <div class="mode-indicators">
                <div class="mode-indicator" style="top: 15%; left: 50%;"></div>
                <div class="mode-indicator" style="top: 50%; right: 15%;"></div>
                <div class="mode-indicator" style="bottom: 15%; left: 50%;"></div>
            </div>
            <div class="knob"></div>
            <div class="display">--:--</div>
            <div class="mode-name"></div>
        </div>
    </div>

    <!-- Navigation Buttons -->
    <div class="nav-button-container">
        <div class="nav-button active" id="btn-calendar" aria-label="Calendar View"></div>
        <div class="nav-button" id="btn-timer" aria-label="Timer View"></div>
    </div>

    <!-- Calendar View Scripts -->
    <script>
        // Calendar Variables
        const editorCalendar = document.getElementById('editor-calendar');
        const dayNameElementCalendar = document.getElementById('day-name-calendar');
        const dateElementCalendar = document.getElementById('date-calendar');
        const monthNameElementCalendar = document.getElementById('month-name-calendar');
        const greetingMessageElementCalendar = document.getElementById('greeting-message-calendar');

        const fullscreenBtnCalendar = document.getElementById('fullscreen-btn-calendar');
        const headerCalendar = document.getElementById('header-calendar');

        let longPressTimerCalendar;
        const longPressDurationCalendar = 500; // milliseconds

        // Function to enter fullscreen
        function enterFullscreenCalendar() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { /* Safari */
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { /* IE11 */
                elem.msRequestFullscreen();
            }
        }

        // Function to exit fullscreen
        function exitFullscreenCalendar() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
        }

        // Toggle fullscreen mode
        function toggleFullscreenCalendar() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                enterFullscreenCalendar();
            } else {
                exitFullscreenCalendar();
            }
        }

        // Show fullscreen button
        function showFullscreenButtonCalendar() {
            fullscreenBtnCalendar.classList.add('visible');
        }

        // Hide fullscreen button
        function hideFullscreenButtonCalendar() {
            fullscreenBtnCalendar.classList.remove('visible');
        }

        // Event listeners for long press on header
        headerCalendar.addEventListener('touchstart', (e) => {
            // Start the timer
            longPressTimerCalendar = setTimeout(() => {
                showFullscreenButtonCalendar();
            }, longPressDurationCalendar);
        });

        headerCalendar.addEventListener('touchend', (e) => {
            // Clear the timer
            clearTimeout(longPressTimerCalendar);
        });

        headerCalendar.addEventListener('touchmove', (e) => {
            // If user moves finger, cancel the long press
            clearTimeout(longPressTimerCalendar);
        });

        // Hide fullscreen button when tapping outside
        document.addEventListener('touchstart', (e) => {
            if (!fullscreenBtnCalendar.contains(e.target) && !headerCalendar.contains(e.target)) {
                hideFullscreenButtonCalendar();
            }
        });

        // Click event for fullscreen button
        fullscreenBtnCalendar.addEventListener('click', () => {
            toggleFullscreenCalendar();
            hideFullscreenButtonCalendar();
        });

        // Existing JavaScript code for Calendar...
        const danishDaysCalendar = ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag'];
        const danishMonthsCalendar = ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'];

        const startDateCalendar = 3; // October 3
        const startMonthCalendar = 9; // October (0-based index)
        const endMonthCalendar = 11; // December (0-based index)
        const yearCalendar = 2024;

        const canvasKeysCalendar = [];
        let totalDaysCalendar = 0;

        for (let month = startMonthCalendar; month <= endMonthCalendar; month++) {
            const daysInMonth = new Date(yearCalendar, month + 1, 0).getDate();
            const startDay = month === startMonthCalendar ? startDateCalendar : 1;
            for (let day = startDay; day <= daysInMonth; day++) {
                canvasKeysCalendar.push(`canvas${yearCalendar}${(month + 1).toString().padStart(2, '0')}${day.toString().padStart(2, '0')}`);
                totalDaysCalendar++;
            }
        }

        let currentCanvasIndexCalendar = 0;

        const hoverSoundCalendar = new Audio('Hover.wav');
        const clickSoundCalendar = new Audio('click.mp3');

        // Load canvases from localStorage or initialize them
        const canvasesCalendar = canvasKeysCalendar.map(key => localStorage.getItem(key) || '');

        // Load messages from messages.json
        let greetingsCalendar = {
            morning: [],
            afternoon: [],
            evening: []
        };
        let congratulatoryMessagesCalendar = [];

        fetch('messages.json')
            .then(response => response.json())
            .then(data => {
                greetingsCalendar = data.greetings;
                congratulatoryMessagesCalendar = data.congratulations;
                // After loading messages, set the initial greeting
                selectGreetingCalendar();
            })
            .catch(error => {
                console.error('Error fetching messages:', error);
                // Fallback greeting messages in case of error
                greetingsCalendar.morning = [
                    "Morning, Mr. M! How about we kick things off with today’s game plan?",
                    "Good morning, Mr. M! Let’s set our sights on a productive day!"
                ];
                greetingsCalendar.afternoon = [
                    "Good afternoon, Mr. M! How’s the day going? Ready to map out what's next?",
                    "Hey Mr. M! Let’s take a quick look at the afternoon's plan."
                ];
                greetingsCalendar.evening = [
                    "Good evening, Mr. M! Shall we go over the day's accomplishments?",
                    "Hey Mr. M! Let’s recap and prep for tomorrow!"
                ];
                selectGreetingCalendar();
            });

        // Work Blocks Variables
        const workBlockKeys = canvasKeysCalendar.map(key => ({
            block1: `${key}-workBlock1`,
            block2: `${key}-workBlock2`,
            block3: `${key}-workBlock3`,
            title1: `${key}-workBlockTitle1`,
            title2: `${key}-workBlockTitle2`,
            title3: `${key}-workBlockTitle3`
        }));

        // Arrays to store the content
        const workBlocksContent = canvasKeysCalendar.map(key => ({
            block1: localStorage.getItem(`${key}-workBlock1`) || '',
            block2: localStorage.getItem(`${key}-workBlock2`) || '',
            block3: localStorage.getItem(`${key}-workBlock3`) || '',
            title1: localStorage.getItem(`${key}-workBlockTitle1`) || 'Work Block 1',
            title2: localStorage.getItem(`${key}-workBlockTitle2`) || 'Work Block 2',
            title3: localStorage.getItem(`${key}-workBlockTitle3`) || 'Work Block 3'
        }));

        function updateEditorCalendar() {
            let currentDay = startDateCalendar;
            let currentMonth = startMonthCalendar;
            for (let i = 0; i < currentCanvasIndexCalendar; i++) {
                currentDay++;
                if (currentDay > new Date(yearCalendar, currentMonth + 1, 0).getDate()) {
                    currentDay = 1;
                    currentMonth++;
                }
            }
            const date = new Date(yearCalendar, currentMonth, currentDay);
            dayNameElementCalendar.innerText = danishDaysCalendar[date.getDay()];
            dateElementCalendar.innerText = currentDay;
            monthNameElementCalendar.innerText = danishMonthsCalendar[currentMonth];
            editorCalendar.innerHTML = canvasesCalendar[currentCanvasIndexCalendar];

            // Load Work Blocks content
            workBlockElements.block1.innerHTML = workBlocksContent[currentCanvasIndexCalendar].block1;
            workBlockElements.block2.innerHTML = workBlocksContent[currentCanvasIndexCalendar].block2;
            workBlockElements.block3.innerHTML = workBlocksContent[currentCanvasIndexCalendar].block3;

            workBlockTitleElements.block1.innerText = workBlocksContent[currentCanvasIndexCalendar].title1;
            workBlockTitleElements.block2.innerText = workBlocksContent[currentCanvasIndexCalendar].title2;
            workBlockTitleElements.block3.innerText = workBlocksContent[currentCanvasIndexCalendar].title3;

            // Check if Work Blocks are completed
            Object.values(workBlockElements).forEach(blockElement => {
                checkWorkBlockCompletion(blockElement.parentNode);
            });
        }

        function saveCurrentCanvasCalendar() {
            canvasesCalendar[currentCanvasIndexCalendar] = editorCalendar.innerHTML;
            localStorage.setItem(canvasKeysCalendar[currentCanvasIndexCalendar], editorCalendar.innerHTML);

            // Save Work Blocks content
            workBlocksContent[currentCanvasIndexCalendar].block1 = workBlockElements.block1.innerHTML;
            workBlocksContent[currentCanvasIndexCalendar].block2 = workBlockElements.block2.innerHTML;
            workBlocksContent[currentCanvasIndexCalendar].block3 = workBlockElements.block3.innerHTML;

            workBlocksContent[currentCanvasIndexCalendar].title1 = workBlockTitleElements.block1.innerText;
            workBlocksContent[currentCanvasIndexCalendar].title2 = workBlockTitleElements.block2.innerText;
            workBlocksContent[currentCanvasIndexCalendar].title3 = workBlockTitleElements.block3.innerText;

            localStorage.setItem(workBlockKeys[currentCanvasIndexCalendar].block1, workBlockElements.block1.innerHTML);
            localStorage.setItem(workBlockKeys[currentCanvasIndexCalendar].block2, workBlockElements.block2.innerHTML);
            localStorage.setItem(workBlockKeys[currentCanvasIndexCalendar].block3, workBlockElements.block3.innerHTML);

            localStorage.setItem(workBlockKeys[currentCanvasIndexCalendar].title1, workBlockTitleElements.block1.innerText);
            localStorage.setItem(workBlockKeys[currentCanvasIndexCalendar].title2, workBlockTitleElements.block2.innerText);
            localStorage.setItem(workBlockKeys[currentCanvasIndexCalendar].title3, workBlockTitleElements.block3.innerText);
        }

        function translateTextCalendar(text) {
            // Adjusted translation to avoid interfering with '.'
            return text
                .replace(/;/g, 'æ')
                .replace(/'/g, 'ø')
                .replace(/\[/g, 'å');
                // Removed the regex that replaces two digits with a dot
        }

        function setCurrentCanvasIndexCalendar() {
            const today = new Date();
            if (today >= new Date(yearCalendar, startMonthCalendar, startDateCalendar) && today <= new Date(yearCalendar, endMonthCalendar + 1, 0)) {
                const daysSinceStart = Math.floor((today - new Date(yearCalendar, startMonthCalendar, startDateCalendar)) / (1000 * 60 * 60 * 24));
                currentCanvasIndexCalendar = Math.min(daysSinceStart, totalDaysCalendar - 1);
            } else {
                currentCanvasIndexCalendar = 0;
            }
        }

        function showPreviousCanvasCalendar() {
            saveCurrentCanvasCalendar();
            currentCanvasIndexCalendar = (currentCanvasIndexCalendar === 0) ? canvasesCalendar.length - 1 : currentCanvasIndexCalendar - 1;
            hoverSoundCalendar.play();
            updateEditorCalendar();
        }

        function showNextCanvasCalendar() {
            saveCurrentCanvasCalendar();
            currentCanvasIndexCalendar = (currentCanvasIndexCalendar === canvasesCalendar.length - 1) ? 0 : currentCanvasIndexCalendar + 1;
            hoverSoundCalendar.play();
            updateEditorCalendar();
        }

        let messageTimeoutCalendar; // To track the message display timeout

        function handleClickCalendar(event) {
            if (event.target.classList.contains('clickable')) {
                // Toggle the 'completed' class
                if (event.target.classList.contains('completed')) {
                    event.target.classList.remove('completed');
                    // If it's a need-to-do item, re-add the glow animation
                    if (event.target.classList.contains('need-to-do')) {
                        event.target.style.animation = '';
                    }
                } else {
                    event.target.classList.add('completed');
                    clickSoundCalendar.play();

                    // Stop the glow animation when completed
                    event.target.style.animation = 'none';

                    // Display a random congratulatory message
                    displayCongratulatoryMessageCalendar();

                    // Check if all tasks in the block are completed
                    if (event.target.closest('.work-block')) {
                        checkWorkBlockCompletion(event.target.closest('.work-block'));
                    }
                }
                // Save the updated content after toggling
                saveCurrentCanvasCalendar();
            }
        }

        function openChat() {
            window.open('https://huggingface.co/chat/', '_blank');
        }

        // Function to select and display the appropriate greeting based on time of day
        function selectGreetingCalendar() {
            const now = new Date();
            const hours = now.getHours();
            let message = "";

            if (hours >= 5 && hours < 12) { // Morning: 5 AM - 12 PM
                message = getRandomMessageCalendar(greetingsCalendar.morning);
            } else if (hours >= 12 && hours < 18) { // Afternoon: 12 PM - 6 PM
                message = getRandomMessageCalendar(greetingsCalendar.afternoon);
            } else { // Evening: 6 PM - 5 AM
                message = getRandomMessageCalendar(greetingsCalendar.evening);
            }

            greetingMessageElementCalendar.innerText = message;
            greetingMessageElementCalendar.classList.remove('hidden'); // Ensure it's visible
        }

        // Helper function to get a random message from a given array
        function getRandomMessageCalendar(messageArray) {
            if (messageArray.length === 0) return "";
            const randomIndex = Math.floor(Math.random() * messageArray.length);
            return messageArray[randomIndex];
        }

        // Function to display a congratulatory message
        function displayCongratulatoryMessageCalendar() {
            if (congratulatoryMessagesCalendar.length === 0) return; // Ensure messages are loaded

            // Select a random message
            const randomIndex = Math.floor(Math.random() * congratulatoryMessagesCalendar.length);
            const message = congratulatoryMessagesCalendar[randomIndex];
            const fullMessage = `${message.icon} ${message.text}`;

            // Clear any existing timeout to prevent multiple messages overlapping
            if (messageTimeoutCalendar) {
                clearTimeout(messageTimeoutCalendar);
                messageTimeoutCalendar = null;
            }

            // Set the congratulatory message
            greetingMessageElementCalendar.innerText = fullMessage;

            // Remove 'hidden' class to trigger fade-in
            greetingMessageElementCalendar.classList.remove('hidden');

            // After 20 seconds, fade out and revert to greeting
            messageTimeoutCalendar = setTimeout(() => {
                // Add 'hidden' class to trigger fade-out
                greetingMessageElementCalendar.classList.add('hidden');

                // After fade-out transition (0.5s), revert to default greeting
                setTimeout(() => {
                    selectGreetingCalendar();
                }, 500); // Match the CSS transition duration
            }, 20000); // 20 seconds
        }

        // Function to handle special character conversion in any contenteditable area
        function handleSpecialCharacterConversion(element, char) {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            const node = range.startContainer;

            // Ensure we're dealing with a text node
            if (node.nodeType !== Node.TEXT_NODE) return;
            const text = node.textContent;
            const charIndex = text.lastIndexOf(char);

            // If the character is found at the end of the text
            if (charIndex === text.length - 1) {
                const beforeChar = text.slice(0, charIndex).trim();

                if (beforeChar.length === 0) return; // Avoid empty lines

                // Replace the text node with a clickable span
                const span = document.createElement('span');
                span.classList.add('clickable');
                if (char === '!') {
                    span.classList.add('need-to-do');
                }
                span.textContent = beforeChar;

                // Replace the text node with the span
                node.parentNode.replaceChild(span, node);

                // Insert a line break after the span
                const br = document.createElement('br');
                span.parentNode.insertBefore(br, span.nextSibling);

                // Move the cursor to the new line after the line break
                const newRange = document.createRange();
                newRange.setStartAfter(br);
                newRange.collapse(true);

                // Update the selection to the new range
                selection.removeAllRanges();
                selection.addRange(newRange);

                // Save the updated content
                saveCurrentCanvasCalendar();
            }
        }

        // Universal Keyup Event Listener for Immediate '.' and '!' Detection
        function addSpecialCharacterListener(element) {
            element.addEventListener('keyup', (e) => {
                if (e.key === '.' || e.key === '!') {
                    handleSpecialCharacterConversion(element, e.key);
                }
            });
        }

        // Apply to all contenteditable areas
        addSpecialCharacterListener(editorCalendar);
        Object.values(workBlockElements).forEach(blockElement => {
            addSpecialCharacterListener(blockElement);
        });

        // Input Event Listener for Translation and Saving
        function addInputListener(element) {
            element.addEventListener('input', () => {
                // Immediate processing without delay

                const translatedText = translateTextCalendar(element.innerText);
                if (translatedText !== element.innerText) {
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        const cursorPosition = range.startOffset;
                        element.innerText = translatedText;
                        const newRange = document.createRange();
                        newRange.setStart(element.firstChild, cursorPosition);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                }

                // Save the current content
                saveCurrentCanvasCalendar();
            });
        }

        // Apply to all contenteditable areas
        addInputListener(editorCalendar);
        Object.values(workBlockElements).forEach(blockElement => {
            addInputListener(blockElement);
        });
        Object.values(workBlockTitleElements).forEach(titleElement => {
            addInputListener(titleElement);
        });

        // Click Event Listener for Marking Tasks as Completed
        function addClickListener(element) {
            element.addEventListener('click', handleClickCalendar);
        }

        // Apply to all contenteditable areas
        addClickListener(editorCalendar);
        Object.values(workBlockElements).forEach(blockElement => {
            addClickListener(blockElement);
        });

        // Function to check if all tasks in a Work Block are completed
        function checkWorkBlockCompletion(workBlockElement) {
            const tasks = workBlockElement.querySelectorAll('.block-tasks .clickable');
            const completedTasks = workBlockElement.querySelectorAll('.block-tasks .clickable.completed');

            const blockTitleElement = workBlockElement.querySelector('.block-title');

            if (tasks.length > 0 && tasks.length === completedTasks.length) {
                // All tasks are completed
                blockTitleElement.classList.add('completed');
                workBlockElement.classList.add('completed');
            } else {
                // Not all tasks are completed
                blockTitleElement.classList.remove('completed');
                workBlockElement.classList.remove('completed');
            }
        }

        // Work Blocks JavaScript
        const workBlockElements = {
            block1: document.querySelector('.work-block[data-block-index="1"] .block-tasks'),
            block2: document.querySelector('.work-block[data-block-index="2"] .block-tasks'),
            block3: document.querySelector('.work-block[data-block-index="3"] .block-tasks')
        };

        const workBlockTitleElements = {
            block1: document.querySelector('.work-block[data-block-index="1"] .block-title'),
            block2: document.querySelector('.work-block[data-block-index="2"] .block-title'),
            block3: document.querySelector('.work-block[data-block-index="3"] .block-title')
        };

        // Event listeners for navigation and clicks
        dateElementCalendar.addEventListener('click', showPreviousCanvasCalendar);
        dayNameElementCalendar.addEventListener('click', showNextCanvasCalendar);

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                showPreviousCanvasCalendar();
            } else if (e.key === 'ArrowRight') {
                showNextCanvasCalendar();
            }
        });

        setCurrentCanvasIndexCalendar();
        updateEditorCalendar();
        // Greeting is set after messages are fetched
    </script>

    <!-- Timer View Scripts -->
    <script>
        // Timer Variables
        const knobTimer = document.querySelector('#timer-view .knob');
        const displayTimer = document.querySelector('#timer-view .display');
        const modeNameTimer = document.querySelector('#timer-view .mode-name');
        const progressRingTimer = document.querySelector('#timer-view .progress');
        const modeIndicatorsTimer = document.querySelectorAll('#timer-view .mode-indicator');
        const containerTimer = document.querySelector('#timer-view .timer-container');
        const canvasTimer = document.querySelector('#timer-view .connecting-circle');
        const ctxTimer = canvasTimer.getContext('2d');

        // Sound effects
        const hoverSoundTimer = new Audio('Hover.wav');
        const clickSoundTimer = new Audio('click.mp3');
        const alarmSoundTimer = new Audio('1.mp3');

        let angleTimer = 0;
        let isDraggingTimer = false;
        let startAngleTimer = 0;
        let currentModeTimer = 0;
        let timerDurationTimer = 0;
        let timerIntervalTimer;
        let modeChangeTimeoutTimer;
        let animationFrameTimer;
        let isKnobMovedTimer = false;
        let audioUnlockedTimer = false;

        const modesTimer = ['Pomodoro', 'Break', 'SoMe'];
        const maxDurationsTimer = [25 * 60, 5 * 60, 7 * 60]; // in seconds

        function setRotationTimer(degrees) {
            knobTimer.style.transform = `rotate(${degrees}deg) translate(120px) rotate(-${degrees}deg)`;
        }

        function setProgressTimer(percent) {
            const circumference = 2 * Math.PI * 45;
            const offset = circumference - (percent / 100) * circumference;
            progressRingTimer.style.strokeDasharray = `${circumference} ${circumference}`;
            progressRingTimer.style.strokeDashoffset = offset;
        }

        function formatTimeTimer(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimerTimer() {
            timerDurationTimer--;
            if (timerDurationTimer <= 0) {
                clearInterval(timerIntervalTimer);
                cancelAnimationFrame(animationFrameTimer);
                playAlarmTimer();
                return;
            }
            displayTimer.textContent = formatTimeTimer(timerDurationTimer);
            setProgressTimer((1 - timerDurationTimer / maxDurationsTimer[currentModeTimer]) * 100);
        }

        function startTimerTimer() {
            clearInterval(timerIntervalTimer);
            cancelAnimationFrame(animationFrameTimer);
            timerDurationTimer = maxDurationsTimer[currentModeTimer];
            displayTimer.textContent = formatTimeTimer(timerDurationTimer);
            setProgressTimer(0);
            timerIntervalTimer = setInterval(updateTimerTimer, 1000);
            animateConnectingCircleTimer();

            // Play the click sound when the timer starts
            clickSoundTimer.play();
        }

        function playAlarmTimer() {
            let alarmCount = 0;
            const maxAlarms = 5;

            function playAlarmSoundTimer() {
                if (alarmCount < maxAlarms) {
                    const playPromise = alarmSoundTimer.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            alarmCount++;
                            // Wait for the duration of the alarm sound before playing again
                            setTimeout(playAlarmSoundTimer, alarmSoundTimer.duration * 1000);
                        }).catch(error => {
                            console.error('Failed to play alarm sound:', error);
                        });
                    } else {
                        // Fallback if play() is undefined
                        alarmCount++;
                        setTimeout(playAlarmSoundTimer, 1000);
                    }
                } else {
                    // After playing the alarm 5 times, reset to show the current time
                    updateCurrentTimeTimer();
                    isKnobMovedTimer = false; // Reset to show time mode
                }
            }

            playAlarmSoundTimer();
        }

        function showModeNameTimer() {
            modeNameTimer.textContent = modesTimer[currentModeTimer];
            modeNameTimer.style.opacity = '1';
            displayTimer.style.opacity = '0';
        }

        function hideModeNameTimer() {
            modeNameTimer.style.opacity = '0';
            displayTimer.style.opacity = '1';
        }

        function updateCurrentTimeTimer() {
            if (!isKnobMovedTimer) {
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                displayTimer.textContent = `${hours}:${minutes}`;
            }
        }

        function unlockAudioTimer() {
            if (!audioUnlockedTimer) {
                // Attempt to play a silent audio to unlock the audio context
                const silentAudio = new Audio();
                silentAudio.muted = true;
                const playPromise = silentAudio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        audioUnlockedTimer = true;
                        silentAudio.pause();
                        silentAudio.src = '';
                    }).catch(error => {
                        console.warn('Audio unlock failed:', error);
                    });
                }
            }
        }

        function startDragTimer(e) {
            isDraggingTimer = true;
            isKnobMovedTimer = true;
            const rect = containerTimer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            startAngleTimer = Math.atan2(clientY - centerY, clientX - centerX);
            clearTimeout(modeChangeTimeoutTimer);

            // Play hover sound when starting to drag the knob
            hoverSoundTimer.play();

            // Unlock audio on first user interaction
            unlockAudioTimer();
        }

        function dragTimer(e) {
            if (!isDraggingTimer) return;
            const rect = containerTimer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const currentAngleRad = Math.atan2(clientY - centerY, clientX - centerX);
            let deltaAngle = (currentAngleRad - startAngleTimer) * (180 / Math.PI);
            // Adjust deltaAngle to ensure smooth rotation
            if (deltaAngle > 180) deltaAngle -= 360;
            if (deltaAngle < -180) deltaAngle += 360;
            angleTimer += deltaAngle;
            angleTimer = (angleTimer + 360) % 360;
            setRotationTimer(angleTimer);
            startAngleTimer = currentAngleRad;

            const newMode = Math.floor(angleTimer / 120) % modesTimer.length;
            if (newMode !== currentModeTimer) {
                currentModeTimer = newMode;
                modeIndicatorsTimer.forEach((indicator, index) => {
                    indicator.classList.toggle('active', index === currentModeTimer);
                });
                showModeNameTimer();
                timerDurationTimer = maxDurationsTimer[currentModeTimer];
                displayTimer.textContent = formatTimeTimer(timerDurationTimer);
                setProgressTimer(0);
            }
        }

        function endDragTimer() {
            if (isDraggingTimer) {
                isDraggingTimer = false;
                modeChangeTimeoutTimer = setTimeout(() => {
                    hideModeNameTimer();
                    startTimerTimer();
                }, 2000);

                // Play click sound only if the knob was being dragged
                clickSoundTimer.play();
            }
        }

        function animateConnectingCircleTimer() {
            ctxTimer.clearRect(0, 0, canvasTimer.width, canvasTimer.height);
            ctxTimer.save();
            ctxTimer.translate(canvasTimer.width / 2, canvasTimer.height / 2);
            
            const time = Date.now() * 0.0005;
            const radius = 135;
            
            ctxTimer.beginPath();
            for (let i = 0; i < 36; i++) {
                const angleDeg = i * 10;
                const angleRad = angleDeg * Math.PI / 180;
                const x = radius * Math.cos(angleRad);
                const y = radius * Math.sin(angleRad);
                const nextAngleRad = angleRad + time * 1.44;
                const nextX = radius * Math.cos(nextAngleRad);
                const nextY = radius * Math.sin(nextAngleRad);
                
                ctxTimer.moveTo(x, y);
                ctxTimer.lineTo(nextX, nextY);
                
                ctxTimer.strokeStyle = `rgba(255, 255, 255, ${0.1 + 0.2 * Math.sin(time + i * 0.2)})`;
                ctxTimer.lineWidth = 1.5;
                ctxTimer.stroke();
            }
            
            ctxTimer.restore();
            
            animationFrameTimer = requestAnimationFrame(animateConnectingCircleTimer);
        }

        // Event listeners
        containerTimer.addEventListener('mousedown', startDragTimer);
        containerTimer.addEventListener('touchstart', startDragTimer);

        document.addEventListener('mousemove', dragTimer);
        document.addEventListener('touchmove', dragTimer);

        document.addEventListener('mouseup', endDragTimer);
        document.addEventListener('touchend', endDragTimer);

        // Initialize Timer
        setRotationTimer(0);
        setProgressTimer(0);
        timerDurationTimer = maxDurationsTimer[currentModeTimer];
        updateCurrentTimeTimer();
        setInterval(updateCurrentTimeTimer, 1000);
    </script>

    <!-- Navigation Script -->
    <script>
        const btnCalendar = document.getElementById('btn-calendar');
        const btnTimer = document.getElementById('btn-timer');
        const calendarView = document.getElementById('calendar-view');
        const timerView = document.getElementById('timer-view');
        const navButtons = document.querySelectorAll('.nav-button');

        btnCalendar.addEventListener('click', () => {
            showView('calendar');
        });

        btnTimer.addEventListener('click', () => {
            showView('timer');
        });

        function showView(view) {
            if (view === 'calendar') {
                calendarView.classList.add('active-view');
                timerView.classList.remove('active-view');
                btnCalendar.classList.add('active');
                btnTimer.classList.remove('active');
            } else if (view === 'timer') {
                timerView.classList.add('active-view');
                calendarView.classList.remove('active-view');
                btnTimer.classList.add('active');
                btnCalendar.classList.remove('active');
            }
        }

        // Optional: Allow keyboard navigation (e.g., using Tab or other keys)
        // You can add more event listeners here if needed.
    </script>
</body>
</html>
