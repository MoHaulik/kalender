<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Calendar, To-Do List, Timer, and Live Text Copier with Firebase Integration</title>
    <style>
        /* Shared Styles */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e7eb 100%);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .view-container {
            flex: 1;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 20px;
            position: relative;
            width: 100%;
            height: 100%;
        }

        .active-view {
            display: flex; /* Show the active view */
        }

        /* Calendar Styles */
        .calendar-container {
            position: relative;
            width: 80%;
            max-width: 600px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 20px;
            color: rgba(0, 0, 0, 0.8);
            height: 70%; /* Adjusted to allow space for scrolling */
        }

        #header-calendar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 10px;
            box-sizing: border-box;
            position: relative;
            flex-shrink: 0;
        }

        #date-container-calendar {
            text-align: left;
        }

        #date-calendar, #day-name-calendar, #month-name-calendar {
            font-size: 24px;
            margin: 0;
            line-height: 1.2;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer; /* Added cursor pointer for clickable dates */
        }

        #to-do-list-container {
            width: 100%;
            overflow-y: auto;
            flex: 1;
            padding: 10px;
            box-sizing: border-box;
        }

        #editor-calendar {
            width: 100%;
            border: none;
            outline: none;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin-top: 10px;
            font-size: 26px;
            background: transparent;
            color: inherit;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .clickable {
            cursor: pointer;
            transition: text-decoration 0.3s ease, color 0.3s ease;
        }

        .clickable:hover {
            text-decoration: underline;
        }

        .completed {
            text-decoration: line-through;
            color: gray;
            transition: text-decoration 0.3s ease, color 0.3s ease;
            animation: none; /* Stop any animation */
            text-shadow: none; /* Remove any text shadow */
        }

        /* Need to do items */
        .need-to-do {
            animation: glow 1s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from {
                text-shadow: 0 0 5px rgba(255, 0, 0, 0.5);
            }
            to {
                text-shadow: 0 0 20px rgba(255, 0, 0, 1);
            }
        }

        /* Avatar Box Styling */
        .avatar-box {
            position: relative;
            width: 80%;
            max-width: 600px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            display: flex;
            align-items: center;
            border-radius: 20px;
            gap: 15px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .avatar {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .avatar img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .text-bubble {
            position: relative;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px 15px;
            border-radius: 15px;
            color: rgba(0, 0, 0, 0.8);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-shadow: 0 1px 5px rgba(0, 0, 0, 0.05);
            flex-grow: 1;
            transition: opacity 0.5s ease;
            opacity: 1;
        }

        .text-bubble.hidden {
            opacity: 0;
        }

        /* Fullscreen Button Styling */
        .fullscreen-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 10;
        }

        .fullscreen-button.visible {
            opacity: 1;
        }

        /* Fullscreen Button Icon */
        .fullscreen-button::before {
            content: "\26F6";
            font-size: 20px;
            color: black;
        }

        /* Timer Styles */
        .timer-container {
            position: relative;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .progress-ring {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .progress-ring circle {
            fill: none;
            stroke: rgba(255, 255, 255, 0.3);
            stroke-width: 8;
        }

        .progress-ring .progress {
            stroke: rgba(255, 255, 255, 0.8);
            stroke-linecap: round;
            transition: stroke-dashoffset 0.5s ease;
        }

        .connecting-circle {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .knob {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.9), rgba(255, 255, 255, 0.4));
            border-radius: 50%;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            position: absolute;
            top: calc(50% - 30px);
            left: calc(50% - 30px);
            transition: box-shadow 0.3s ease;
            z-index: 10;
        }

        .knob:hover {
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        }

        .knob:active {
            box-shadow: 0 0 30px rgba(255, 255, 255, 0.7);
        }

        .display {
            font-size: 48px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: relative;
            z-index: 5;
        }

        .mode-indicators {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        .mode-indicator {
            position: absolute;
            width: 10px;
            height: 10px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transition: background 0.3s ease;
        }

        .mode-indicator.active {
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }

        .mode-name {
            font-size: 24px;
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            opacity: 0;
            transition: opacity 0.3s ease;
            position: relative;
            z-index: 5;
        }

        /* Navigation Button Styles */
        .nav-button-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-button {
            width: 15px;
            height: 15px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .nav-button.active {
            background: rgba(255, 255, 255, 1);
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.2);
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .calendar-container, .avatar-box {
                width: 90%;
                padding: 15px;
            }

            #date-calendar, #day-name-calendar, #month-name-calendar {
                font-size: 20px;
            }

            #editor-calendar {
                font-size: 22px;
            }

            .text-bubble {
                font-size: 16px;
            }

            .fullscreen-button {
                width: 35px;
                height: 35px;
                top: 8px;
                right: 8px;
            }

            .fullscreen-button::before {
                font-size: 18px;
            }

            .timer-container {
                width: 250px;
                height: 250px;
            }

            .display {
                font-size: 36px;
            }

            .mode-name {
                font-size: 20px;
            }

            .knob {
                width: 50px;
                height: 50px;
                top: calc(50% - 25px);
                left: calc(50% - 25px);
            }

            .nav-button {
                width: 12px;
                height: 12px;
            }
        }

        /* Work Block Styles */
        #work-blocks-container {
            width: 100%;
            margin-top: 20px;
        }

        .work-block {
            position: relative;
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 15px;
            overflow: hidden;
            transition: background 0.5s ease;
            background-size: 600% 600%;
            animation: soap-bubble 10s ease infinite;
        }

        .block-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            cursor: text; /* Indicate editable text */
        }

        .block-tasks {
            font-size: 20px;
            min-height: 50px;
        }

        .work-block.completed .block-title {
            text-decoration: line-through;
            color: gray;
        }

        .work-block.completed {
            background: rgba(200, 200, 200, 0.5);
            animation: none;
        }

        .work-block[data-block-index="1"] {
            background: linear-gradient(270deg, #ff7f50, #87cefa, #da70d6);
        }

        .work-block[data-block-index="2"] {
            background: linear-gradient(270deg, #7fffd4, #ffe4e1, #f0e68c);
        }

        .work-block[data-block-index="3"] {
            background: linear-gradient(270deg, #dda0dd, #afeeee, #98fb98);
        }

        @keyframes soap-bubble {
            0% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
            100% {
                background-position: 0% 50%;
            }
        }

        /* Live Text Copier Styles */
        /* Styles from the second HTML code */
        /* Adjusted to match the main app's styles */

        /* Main Container for Live Text Copier */
        .text-copier-container {
            position: relative;
            width: 90%;
            max-width: 700px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 20px;
        }

        /* Textarea */
        .text-copier-container textarea {
            width: 100%;
            height: 300px;
            padding: 15px;
            border: none;
            outline: none;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-size: 16px;
            color: rgba(0, 0, 0, 0.8);
            resize: none;
        }

        .text-copier-container textarea::placeholder {
            color: rgba(0, 0, 0, 0.5);
        }

        /* Buttons */
        .text-copier-container button {
            margin-top: 10px;
            padding: 10px 20px;
            font-size: 16px;
            color: white;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 10px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .text-copier-container button:hover {
            background: linear-gradient(135deg, #764ba2, #667eea);
        }

        .text-copier-container button:active {
            transform: scale(0.98);
        }

        /* Status message */
        #status {
            margin-top: 10px;
            font-size: 14px;
            color: rgba(0, 0, 0, 0.8);
        }

        /* Gear (Settings) */
        .settings-button {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: white;
            border-radius: 50%;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: transform 0.3s ease;
        }

        .settings-button:hover {
            transform: rotate(30deg);
        }

        .settings-button::before {
            content: "\2699"; /* Unicode for gear icon */
            font-size: 24px;
            color: black;
        }

        /* Settings Menu */
        .settings-menu {
            position: absolute;
            bottom: 80px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            padding: 10px;
            display: none;
            flex-direction: column;
            gap: 10px;
        }

        .settings-menu.active {
            display: flex;
        }

        .settings-menu button {
            width: 100%;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <!-- Calendar View -->
    <div class="view-container active-view" id="calendar-view">
        <div class="calendar-container">
            <div id="header-calendar">
                <div id="date-container-calendar">
                    <div id="date-calendar"></div>
                    <div id="month-name-calendar"></div>
                </div>
                <div id="day-name-calendar"></div>
                <!-- Fullscreen Button -->
                <button class="fullscreen-button" id="fullscreen-btn-calendar" aria-label="Toggle Fullscreen"></button>
            </div>

            <!-- To-Do List Container -->
            <div id="to-do-list-container">
                <div id="editor-calendar" contenteditable="true"></div>

                <!-- Work Blocks Container -->
                <div id="work-blocks-container">
                    <div class="work-block" data-block-index="1">
                        <div class="block-title" contenteditable="true">Work Block 1</div>
                        <div class="block-tasks" contenteditable="true"></div>
                    </div>
                    <div class="work-block" data-block-index="2">
                        <div class="block-title" contenteditable="true">Work Block 2</div>
                        <div class="block-tasks" contenteditable="true"></div>
                    </div>
                    <div class="work-block" data-block-index="3">
                        <div class="block-title" contenteditable="true">Work Block 3</div>
                        <div class="block-tasks" contenteditable="true"></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Avatar Box for Calendar View -->
        <div class="avatar-box" onclick="openChat()">
            <div class="avatar">
                <img src="Avatar.jpeg" alt="Avatar">
            </div>
            <div class="text-bubble" id="greeting-message-calendar">
                <!-- Placeholder for text bubble content -->
            </div>
        </div>
    </div>

    <!-- Timer View -->
    <div class="view-container" id="timer-view">
        <div class="timer-container">
            <svg class="progress-ring" viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="45" />
                <circle class="progress" cx="50" cy="50" r="45" />
            </svg>
            <canvas class="connecting-circle" width="300" height="300"></canvas>
            <div class="mode-indicators">
                <div class="mode-indicator" style="top: 15%; left: 50%;"></div>
                <div class="mode-indicator" style="top: 50%; right: 15%;"></div>
                <div class="mode-indicator" style="bottom: 15%; left: 50%;"></div>
            </div>
            <div class="knob"></div>
            <div class="display">--:--</div>
            <div class="mode-name"></div>
        </div>
    </div>

    <!-- Live Text Copier View -->
    <div class="view-container" id="text-copier-view">
        <div class="text-copier-container">
            <button id="loginButton">Log ind med Google</button>
            <textarea id="textInput" placeholder="Skriv noget her..."></textarea>
            <button onclick="copyText()">Kopier</button>
            <p id="status"></p>

            <!-- Gear (Settings) -->
            <div class="settings-button" id="settingsButton"></div>
            <div class="settings-menu" id="settingsMenu">
                <button id="toggleLoginButton">Skjul Log ind</button>
                <button id="fullscreenButton">Fuldskærm</button>
            </div>
        </div>
    </div>

    <!-- Navigation Buttons -->
    <div class="nav-button-container">
        <div class="nav-button active" id="btn-calendar" aria-label="Calendar View"></div>
        <div class="nav-button" id="btn-timer" aria-label="Timer View"></div>
        <div class="nav-button" id="btn-text-copier" aria-label="Text Copier View"></div>
    </div>

    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.19.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.19.1/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.19.1/firebase-database-compat.js"></script>

    <!-- Calendar View Scripts -->
    <script>
        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAoY_XxClJRTUS6OJmaIDvZm014Lx7sXA4",
            authDomain: "copypaste2000-5776c.firebaseapp.com",
            databaseURL: "https://copypaste2000-5776c-default-rtdb.firebaseio.com",
            projectId: "copypaste2000-5776c",
            storageBucket: "copypaste2000-5776c.appspot.com",
            messagingSenderId: "733249598043",
            appId: "1:733249598043:web:6648bfe9b408127aa6457e",
            measurementId: "G-M16KES53R6"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const database = firebase.database();

        let userId = null; // Placeholder for user ID after login

        // Google Sign-in with Popup
        function signInWithGoogle() {
            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider)
                .then((result) => {
                    console.log("User signed in:", result.user.displayName);
                    userId = result.user.uid; // Save the user's UID
                    // After login, load the to-do list and Work Blocks from Firebase
                    loadDataFromFirebase();
                })
                .catch((error) => {
                    console.error("Login error:", error.message);
                    alert("Login failed: " + error.message);
                });
        }

        // Automatically sign in the user on app start
        document.addEventListener('DOMContentLoaded', () => {
            auth.onAuthStateChanged((user) => {
                if (user) {
                    userId = user.uid;
                    loadDataFromFirebase();
                } else {
                    // If not logged in, sign in with Google
                    signInWithGoogle();
                }
            });
        });

        // Function to load data from Firebase
        function loadDataFromFirebase() {
            if (!userId) return;

            const dateKey = canvasKeysCalendar[currentCanvasIndexCalendar];

            // Load to-do list
            const toDoRef = database.ref(`users/${userId}/toDoList/${dateKey}`);
            toDoRef.once('value', (snapshot) => {
                const content = snapshot.val();
                if (content) {
                    editorCalendar.innerHTML = content;
                } else {
                    editorCalendar.innerHTML = '';
                }
            });

            // Load Work Blocks
            const workBlocksRef = database.ref(`users/${userId}/workBlocks/${dateKey}`);
            workBlocksRef.once('value', (snapshot) => {
                const data = snapshot.val();
                if (data) {
                    workBlockElements.block1.innerHTML = data.block1 || '';
                    workBlockElements.block2.innerHTML = data.block2 || '';
                    workBlockElements.block3.innerHTML = data.block3 || '';
                    workBlockElements.title1.innerText = data.title1 || 'Work Block 1';
                    workBlockElements.title2.innerText = data.title2 || 'Work Block 2';
                    workBlockElements.title3.innerText = data.title3 || 'Work Block 3';
                } else {
                    // If no data, initialize with default values
                    workBlockElements.block1.innerHTML = '';
                    workBlockElements.block2.innerHTML = '';
                    workBlockElements.block3.innerHTML = '';
                    workBlockElements.title1.innerText = 'Work Block 1';
                    workBlockElements.title2.innerText = 'Work Block 2';
                    workBlockElements.title3.innerText = 'Work Block 3';
                }
                // Check if Work Blocks are completed
                Object.values(workBlockElements.blocks).forEach(blockElement => {
                    checkWorkBlockCompletion(blockElement.parentNode);
                });
            });
        }

        // Function to save current canvas data to Firebase
        function saveCurrentCanvasCalendar() {
            if (!userId) return; // Ensure user is logged in

            const dateKey = canvasKeysCalendar[currentCanvasIndexCalendar];

            // Save to-do list
            const toDoRef = database.ref(`users/${userId}/toDoList/${dateKey}`);
            toDoRef.set(editorCalendar.innerHTML);

            // Save Work Blocks
            const workBlocksRef = database.ref(`users/${userId}/workBlocks/${dateKey}`);
            const workBlocksData = {
                block1: workBlockElements.block1.innerHTML,
                block2: workBlockElements.block2.innerHTML,
                block3: workBlockElements.block3.innerHTML,
                title1: workBlockElements.title1.innerText,
                title2: workBlockElements.title2.innerText,
                title3: workBlockElements.title3.innerText
            };
            workBlocksRef.set(workBlocksData);
        }

        // Save data every minute
        setInterval(saveCurrentCanvasCalendar, 60000);

        // Call save function when the window is about to unload
        window.addEventListener('beforeunload', saveCurrentCanvasCalendar);

        // Calendar Variables
        const editorCalendar = document.getElementById('editor-calendar');
        const dayNameElementCalendar = document.getElementById('day-name-calendar');
        const dateElementCalendar = document.getElementById('date-calendar');
        const monthNameElementCalendar = document.getElementById('month-name-calendar');
        const greetingMessageElementCalendar = document.getElementById('greeting-message-calendar');

        const fullscreenBtnCalendar = document.getElementById('fullscreen-btn-calendar');
        const headerCalendar = document.getElementById('header-calendar');

        let longPressTimerCalendar;
        const longPressDurationCalendar = 500; // milliseconds

        // Function to enter fullscreen
        function enterFullscreenCalendar() {
            const elem = document.documentElement;
            if (elem.requestFullscreen) {
                elem.requestFullscreen();
            } else if (elem.webkitRequestFullscreen) { /* Safari */
                elem.webkitRequestFullscreen();
            } else if (elem.msRequestFullscreen) { /* IE11 */
                elem.msRequestFullscreen();
            }
        }

        // Function to exit fullscreen
        function exitFullscreenCalendar() {
            if (document.exitFullscreen) {
                document.exitFullscreen();
            } else if (document.webkitExitFullscreen) { /* Safari */
                document.webkitExitFullscreen();
            } else if (document.msExitFullscreen) { /* IE11 */
                document.msExitFullscreen();
            }
        }

        // Toggle fullscreen mode
        function toggleFullscreenCalendar() {
            if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                enterFullscreenCalendar();
            } else {
                exitFullscreenCalendar();
            }
        }

        // Show fullscreen button
        function showFullscreenButtonCalendar() {
            fullscreenBtnCalendar.classList.add('visible');
        }

        // Hide fullscreen button
        function hideFullscreenButtonCalendar() {
            fullscreenBtnCalendar.classList.remove('visible');
        }

        // Event listeners for long press on header
        headerCalendar.addEventListener('touchstart', (e) => {
            // Start the timer
            longPressTimerCalendar = setTimeout(() => {
                showFullscreenButtonCalendar();
            }, longPressDurationCalendar);
        });

        headerCalendar.addEventListener('touchend', (e) => {
            // Clear the timer
            clearTimeout(longPressTimerCalendar);
        });

        headerCalendar.addEventListener('touchmove', (e) => {
            // If user moves finger, cancel the long press
            clearTimeout(longPressTimerCalendar);
        });

        // Hide fullscreen button when tapping outside
        document.addEventListener('touchstart', (e) => {
            if (!fullscreenBtnCalendar.contains(e.target) && !headerCalendar.contains(e.target)) {
                hideFullscreenButtonCalendar();
            }
        });

        // Click event for fullscreen button
        fullscreenBtnCalendar.addEventListener('click', () => {
            toggleFullscreenCalendar();
            hideFullscreenButtonCalendar();
        });

        // Existing JavaScript code for Calendar...
        const danishDaysCalendar = ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag'];
        const danishMonthsCalendar = ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'];

        const startDateCalendar = 3; // October 3
        const startMonthCalendar = 9; // October (0-based index)
        const endMonthCalendar = 11; // December (0-based index)
        const yearCalendar = 2024;

        const canvasKeysCalendar = [];
        let totalDaysCalendar = 0;

        for (let month = startMonthCalendar; month <= endMonthCalendar; month++) {
            const daysInMonth = new Date(yearCalendar, month + 1, 0).getDate();
            const startDay = month === startMonthCalendar ? startDateCalendar : 1;
            for (let day = startDay; day <= daysInMonth; day++) {
                canvasKeysCalendar.push(`canvas${yearCalendar}${(month + 1).toString().padStart(2, '0')}${day.toString().padStart(2, '0')}`);
                totalDaysCalendar++;
            }
        }

        let currentCanvasIndexCalendar = 0;

        const hoverSoundCalendar = new Audio('Hover.wav');
        const clickSoundCalendar = new Audio('click.mp3');

        function updateEditorCalendar() {
            let currentDay = startDateCalendar;
            let currentMonth = startMonthCalendar;
            for (let i = 0; i < currentCanvasIndexCalendar; i++) {
                currentDay++;
                if (currentDay > new Date(yearCalendar, currentMonth + 1, 0).getDate()) {
                    currentDay = 1;
                    currentMonth++;
                }
            }
            const date = new Date(yearCalendar, currentMonth, currentDay);
            dayNameElementCalendar.innerText = danishDaysCalendar[date.getDay()];
            dateElementCalendar.innerText = currentDay;
            monthNameElementCalendar.innerText = danishMonthsCalendar[currentMonth];

            // After updating the date, load data from Firebase
            loadDataFromFirebase();
        }

        function setCurrentCanvasIndexCalendar() {
            const today = new Date();
            if (today >= new Date(yearCalendar, startMonthCalendar, startDateCalendar) && today <= new Date(yearCalendar, endMonthCalendar + 1, 0)) {
                const daysSinceStart = Math.floor((today - new Date(yearCalendar, startMonthCalendar, startDateCalendar)) / (1000 * 60 * 60 * 24));
                currentCanvasIndexCalendar = Math.min(daysSinceStart, totalDaysCalendar - 1);
            } else {
                currentCanvasIndexCalendar = 0;
            }
        }

        function showPreviousCanvasCalendar() {
            saveCurrentCanvasCalendar();
            currentCanvasIndexCalendar = (currentCanvasIndexCalendar === 0) ? canvasKeysCalendar.length - 1 : currentCanvasIndexCalendar - 1;
            hoverSoundCalendar.play();
            updateEditorCalendar();
        }

        function showNextCanvasCalendar() {
            saveCurrentCanvasCalendar();
            currentCanvasIndexCalendar = (currentCanvasIndexCalendar === canvasKeysCalendar.length - 1) ? 0 : currentCanvasIndexCalendar + 1;
            hoverSoundCalendar.play();
            updateEditorCalendar();
        }

        let messageTimeoutCalendar; // To track the message display timeout

        function handleClickCalendar(event) {
            if (event.target.classList.contains('clickable')) {
                // Toggle the 'completed' class
                if (event.target.classList.contains('completed')) {
                    event.target.classList.remove('completed');
                    // If it's a need-to-do item, re-add the glow animation
                    if (event.target.classList.contains('need-to-do')) {
                        event.target.style.animation = '';
                    }
                } else {
                    event.target.classList.add('completed');
                    clickSoundCalendar.play();

                    // Stop the glow animation when completed
                    event.target.style.animation = 'none';

                    // Display a random congratulatory message
                    displayCongratulatoryMessageCalendar();

                    // Check if all tasks are completed in the main editor
                    // You can add additional logic here if needed
                }
                // Save the updated content after toggling
                saveCurrentCanvasCalendar();
            }
        }

        function openChat() {
            window.open('https://huggingface.co/chat/', '_blank');
        }

        // Function to select and display the appropriate greeting based on time of day
        function selectGreetingCalendar() {
            const now = new Date();
            const hours = now.getHours();
            let message = "";

            if (hours >= 5 && hours < 12) { // Morning: 5 AM - 12 PM
                message = getRandomMessageCalendar(greetingsCalendar.morning);
            } else if (hours >= 12 && hours < 18) { // Afternoon: 12 PM - 6 PM
                message = getRandomMessageCalendar(greetingsCalendar.afternoon);
            } else { // Evening: 6 PM - 5 AM
                message = getRandomMessageCalendar(greetingsCalendar.evening);
            }

            greetingMessageElementCalendar.innerText = message;
            greetingMessageElementCalendar.classList.remove('hidden'); // Ensure it's visible
        }

        // Helper function to get a random message from a given array
        function getRandomMessageCalendar(messageArray) {
            if (messageArray.length === 0) return "";
            const randomIndex = Math.floor(Math.random() * messageArray.length);
            return messageArray[randomIndex];
        }

        // Function to display a congratulatory message
        function displayCongratulatoryMessageCalendar() {
            if (congratulatoryMessagesCalendar.length === 0) return; // Ensure messages are loaded

            // Select a random message
            const randomIndex = Math.floor(Math.random() * congratulatoryMessagesCalendar.length);
            const message = congratulatoryMessagesCalendar[randomIndex];
            const fullMessage = `${message.icon} ${message.text}`;

            // Clear any existing timeout to prevent multiple messages overlapping
            if (messageTimeoutCalendar) {
                clearTimeout(messageTimeoutCalendar);
                messageTimeoutCalendar = null;
            }

            // Set the congratulatory message
            greetingMessageElementCalendar.innerText = fullMessage;

            // Remove 'hidden' class to trigger fade-in
            greetingMessageElementCalendar.classList.remove('hidden');

            // After 20 seconds, fade out and revert to greeting
            messageTimeoutCalendar = setTimeout(() => {
                // Add 'hidden' class to trigger fade-out
                greetingMessageElementCalendar.classList.add('hidden');

                // After fade-out transition (0.5s), revert to default greeting
                setTimeout(() => {
                    selectGreetingCalendar();
                }, 500); // Match the CSS transition duration
            }, 20000); // 20 seconds
        }

        // Function to handle special character conversion in any contenteditable element
        function handleSpecialCharacterConversion(element, char) {
            const selection = window.getSelection();
            if (!selection.rangeCount) return;
            const range = selection.getRangeAt(0);
            const node = range.startContainer;

            // Ensure we're dealing with a text node
            if (node.nodeType !== Node.TEXT_NODE) return;
            const text = node.textContent;
            const charIndex = text.lastIndexOf(char);

            // If the character is found at the end of the text
            if (charIndex === text.length - 1) {
                const beforeChar = text.slice(0, charIndex).trim();

                if (beforeChar.length === 0) return; // Avoid empty lines

                // Replace the text node with a clickable span
                const span = document.createElement('span');
                span.classList.add('clickable');
                if (char === '!') {
                    span.classList.add('need-to-do');
                }
                span.textContent = beforeChar;

                // Replace the text node with the span
                node.parentNode.replaceChild(span, node);

                // Insert a line break after the span
                const br = document.createElement('br');
                span.parentNode.insertBefore(br, span.nextSibling);

                // Move the cursor to the new line after the line break
                const newRange = document.createRange();
                newRange.setStartAfter(br);
                newRange.collapse(true);

                // Update the selection to the new range
                selection.removeAllRanges();
                selection.addRange(newRange);

                // Save the updated content
                saveCurrentCanvasCalendar();
            }
        }

        // General function to handle keyup events on contenteditable elements
        function handleKeyUp(event) {
            if (event.key === '.' || event.key === '!') {
                handleSpecialCharacterConversion(event.currentTarget, event.key);
            }
        }

        // General function to handle clicks on tasks in contenteditable elements
        function handleClick(event) {
            if (event.target.classList.contains('clickable')) {
                // Toggle the 'completed' class
                if (event.target.classList.contains('completed')) {
                    event.target.classList.remove('completed');
                    // If it's a need-to-do item, re-add the glow animation
                    if (event.target.classList.contains('need-to-do')) {
                        event.target.style.animation = '';
                    }
                } else {
                    event.target.classList.add('completed');
                    clickSoundCalendar.play();

                    // Stop the glow animation when completed
                    event.target.style.animation = 'none';

                    // Display a random congratulatory message
                    displayCongratulatoryMessageCalendar();

                    // Check if all tasks in the block are completed
                    if (event.currentTarget.classList.contains('block-tasks')) {
                        checkWorkBlockCompletion(event.currentTarget.parentNode);
                    }
                }
                // Save the updated content after toggling
                saveCurrentCanvasCalendar();
            }
        }

        // Function to check if all tasks in a Work Block are completed
        function checkWorkBlockCompletion(workBlockElement) {
            const tasks = workBlockElement.querySelectorAll('.block-tasks .clickable');
            const completedTasks = workBlockElement.querySelectorAll('.block-tasks .clickable.completed');

            const blockTitleElement = workBlockElement.querySelector('.block-title');

            if (tasks.length > 0 && tasks.length === completedTasks.length) {
                // All tasks are completed
                blockTitleElement.classList.add('completed');
                workBlockElement.classList.add('completed');
            } else {
                // Not all tasks are completed
                blockTitleElement.classList.remove('completed');
                workBlockElement.classList.remove('completed');
            }
        }

        // Work Blocks JavaScript
        const workBlockElements = {
            title1: document.querySelector('.work-block[data-block-index="1"] .block-title'),
            title2: document.querySelector('.work-block[data-block-index="2"] .block-title'),
            title3: document.querySelector('.work-block[data-block-index="3"] .block-title'),
            block1: document.querySelector('.work-block[data-block-index="1"] .block-tasks'),
            block2: document.querySelector('.work-block[data-block-index="2"] .block-tasks'),
            block3: document.querySelector('.work-block[data-block-index="3"] .block-tasks'),
            blocks: {
                block1: document.querySelector('.work-block[data-block-index="1"] .block-tasks'),
                block2: document.querySelector('.work-block[data-block-index="2"] .block-tasks'),
                block3: document.querySelector('.work-block[data-block-index="3"] .block-tasks')
            }
        };

        // Add event listeners to Work Blocks and main editor
        [editorCalendar, ...Object.values(workBlockElements.blocks)].forEach(element => {
            element.addEventListener('keyup', handleKeyUp);
            element.addEventListener('click', handleClick);
            // Removed 'input' event listener since we save data periodically
        });

        // Save titles when they are edited
        [workBlockElements.title1, workBlockElements.title2, workBlockElements.title3].forEach(titleElement => {
            // Removed 'input' event listener since we save data periodically
        });

        // Event listeners for navigation and clicks
        dateElementCalendar.addEventListener('click', showPreviousCanvasCalendar);
        dayNameElementCalendar.addEventListener('click', showNextCanvasCalendar);

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                showPreviousCanvasCalendar();
            } else if (e.key === 'ArrowRight') {
                showNextCanvasCalendar();
            }
        });

        setCurrentCanvasIndexCalendar();
        updateEditorCalendar();

        // Load messages from messages.json
        let greetingsCalendar = {
            morning: [],
            afternoon: [],
            evening: []
        };
        let congratulatoryMessagesCalendar = [];

        fetch('messages.json')
            .then(response => response.json())
            .then(data => {
                greetingsCalendar = data.greetings;
                congratulatoryMessagesCalendar = data.congratulations;
                // After loading messages, set the initial greeting
                selectGreetingCalendar();
            })
            .catch(error => {
                console.error('Error fetching messages:', error);
                // Fallback greeting messages in case of error
                greetingsCalendar.morning = [
                    "Morning, Mr. M! How about we kick things off with today’s game plan?",
                    "Good morning, Mr. M! Let’s set our sights on a productive day!"
                ];
                greetingsCalendar.afternoon = [
                    "Good afternoon, Mr. M! How’s the day going? Ready to map out what's next?",
                    "Hey Mr. M! Let’s take a quick look at the afternoon's plan."
                ];
                greetingsCalendar.evening = [
                    "Good evening, Mr. M! Shall we go over the day's accomplishments?",
                    "Hey Mr. M! Let’s recap and prep for tomorrow!"
                ];
                selectGreetingCalendar();
            });

        // Greeting is set after messages are fetched
    </script>

    <!-- Timer View Scripts -->
    <script>
        // Timer Variables
        const knobTimer = document.querySelector('#timer-view .knob');
        const displayTimer = document.querySelector('#timer-view .display');
        const modeNameTimer = document.querySelector('#timer-view .mode-name');
        const progressRingTimer = document.querySelector('#timer-view .progress');
        const modeIndicatorsTimer = document.querySelectorAll('#timer-view .mode-indicator');
        const containerTimer = document.querySelector('#timer-view .timer-container');
        const canvasTimer = document.querySelector('#timer-view .connecting-circle');
        const ctxTimer = canvasTimer.getContext('2d');

        // Sound effects
        const hoverSoundTimer = new Audio('Hover.wav');
        const clickSoundTimer = new Audio('click.mp3');
        const alarmSoundTimer = new Audio('1.mp3');

        let angleTimer = 0;
        let isDraggingTimer = false;
        let startAngleTimer = 0;
        let currentModeTimer = 0;
        let timerDurationTimer = 0;
        let timerIntervalTimer;
        let modeChangeTimeoutTimer;
        let animationFrameTimer;
        let isKnobMovedTimer = false;
        let audioUnlockedTimer = false;

        const modesTimer = ['Pomodoro', 'Break', 'SoMe'];
        const maxDurationsTimer = [25 * 60, 5 * 60, 7 * 60]; // in seconds

        function setRotationTimer(degrees) {
            knobTimer.style.transform = `rotate(${degrees}deg) translate(120px) rotate(-${degrees}deg)`;
        }

        function setProgressTimer(percent) {
            const circumference = 2 * Math.PI * 45;
            const offset = circumference - (percent / 100) * circumference;
            progressRingTimer.style.strokeDasharray = `${circumference} ${circumference}`;
            progressRingTimer.style.strokeDashoffset = offset;
        }

        function formatTimeTimer(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        function updateTimerTimer() {
            timerDurationTimer--;
            if (timerDurationTimer <= 0) {
                clearInterval(timerIntervalTimer);
                cancelAnimationFrame(animationFrameTimer);
                playAlarmTimer();
                return;
            }
            displayTimer.textContent = formatTimeTimer(timerDurationTimer);
            setProgressTimer((1 - timerDurationTimer / maxDurationsTimer[currentModeTimer]) * 100);
        }

        function startTimerTimer() {
            clearInterval(timerIntervalTimer);
            cancelAnimationFrame(animationFrameTimer);
            timerDurationTimer = maxDurationsTimer[currentModeTimer];
            displayTimer.textContent = formatTimeTimer(timerDurationTimer);
            setProgressTimer(0);
            timerIntervalTimer = setInterval(updateTimerTimer, 1000);
            animateConnectingCircleTimer();

            // Play the click sound when the timer starts
            clickSoundTimer.play();
        }

        function playAlarmTimer() {
            let alarmCount = 0;
            const maxAlarms = 5;

            function playAlarmSoundTimer() {
                if (alarmCount < maxAlarms) {
                    const playPromise = alarmSoundTimer.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            alarmCount++;
                            // Wait for the duration of the alarm sound before playing again
                            setTimeout(playAlarmSoundTimer, alarmSoundTimer.duration * 1000);
                        }).catch(error => {
                            console.error('Failed to play alarm sound:', error);
                        });
                    } else {
                        // Fallback if play() is undefined
                        alarmCount++;
                        setTimeout(playAlarmSoundTimer, 1000);
                    }
                } else {
                    // After playing the alarm 5 times, reset to show the current time
                    updateCurrentTimeTimer();
                    isKnobMovedTimer = false; // Reset to show time mode
                }
            }

            playAlarmSoundTimer();
        }

        function showModeNameTimer() {
            modeNameTimer.textContent = modesTimer[currentModeTimer];
            modeNameTimer.style.opacity = '1';
            displayTimer.style.opacity = '0';
        }

        function hideModeNameTimer() {
            modeNameTimer.style.opacity = '0';
            displayTimer.style.opacity = '1';
        }

        function updateCurrentTimeTimer() {
            if (!isKnobMovedTimer) {
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                displayTimer.textContent = `${hours}:${minutes}`;
            }
        }

        function unlockAudioTimer() {
            if (!audioUnlockedTimer) {
                // Attempt to play a silent audio to unlock the audio context
                const silentAudio = new Audio();
                silentAudio.muted = true;
                const playPromise = silentAudio.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        audioUnlockedTimer = true;
                        silentAudio.pause();
                        silentAudio.src = '';
                    }).catch(error => {
                        console.warn('Audio unlock failed:', error);
                    });
                }
            }
        }

        function startDragTimer(e) {
            isDraggingTimer = true;
            isKnobMovedTimer = true;
            const rect = containerTimer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            startAngleTimer = Math.atan2(clientY - centerY, clientX - centerX);
            clearTimeout(modeChangeTimeoutTimer);

            // Play hover sound when starting to drag the knob
            hoverSoundTimer.play();

            // Unlock audio on first user interaction
            unlockAudioTimer();
        }

        function dragTimer(e) {
            if (!isDraggingTimer) return;
            const rect = containerTimer.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            const currentAngleRad = Math.atan2(clientY - centerY, clientX - centerX);
            let deltaAngle = (currentAngleRad - startAngleTimer) * (180 / Math.PI);
            // Adjust deltaAngle to ensure smooth rotation
            if (deltaAngle > 180) deltaAngle -= 360;
            if (deltaAngle < -180) deltaAngle += 360;
            angleTimer += deltaAngle;
            angleTimer = (angleTimer + 360) % 360;
            setRotationTimer(angleTimer);
            startAngleTimer = currentAngleRad;

            const newMode = Math.floor(angleTimer / 120) % modesTimer.length;
            if (newMode !== currentModeTimer) {
                currentModeTimer = newMode;
                modeIndicatorsTimer.forEach((indicator, index) => {
                    indicator.classList.toggle('active', index === currentModeTimer);
                });
                showModeNameTimer();
                timerDurationTimer = maxDurationsTimer[currentModeTimer];
                displayTimer.textContent = formatTimeTimer(timerDurationTimer);
                setProgressTimer(0);
            }
        }

        function endDragTimer() {
            if (isDraggingTimer) {
                isDraggingTimer = false;
                modeChangeTimeoutTimer = setTimeout(() => {
                    hideModeNameTimer();
                    startTimerTimer();
                }, 2000);

                // Play click sound only if the knob was being dragged
                clickSoundTimer.play();
            }
        }

        function animateConnectingCircleTimer() {
            ctxTimer.clearRect(0, 0, canvasTimer.width, canvasTimer.height);
            ctxTimer.save();
            ctxTimer.translate(canvasTimer.width / 2, canvasTimer.height / 2);

            const time = Date.now() * 0.0005;
            const radius = 135;

            ctxTimer.beginPath();
            for (let i = 0; i < 36; i++) {
                const angleDeg = i * 10;
                const angleRad = angleDeg * Math.PI / 180;
                const x = radius * Math.cos(angleRad);
                const y = radius * Math.sin(angleRad);
                const nextAngleRad = angleRad + time * 1.44;
                const nextX = radius * Math.cos(nextAngleRad);
                const nextY = radius * Math.sin(nextAngleRad);

                ctxTimer.moveTo(x, y);
                ctxTimer.lineTo(nextX, nextY);

                ctxTimer.strokeStyle = `rgba(255, 255, 255, ${0.1 + 0.2 * Math.sin(time + i * 0.2)})`;
                ctxTimer.lineWidth = 1.5;
                ctxTimer.stroke();
            }

            ctxTimer.restore();

            animationFrameTimer = requestAnimationFrame(animateConnectingCircleTimer);
        }

        // Event listeners
        containerTimer.addEventListener('mousedown', startDragTimer);
        containerTimer.addEventListener('touchstart', startDragTimer);

        document.addEventListener('mousemove', dragTimer);
        document.addEventListener('touchmove', dragTimer);

        document.addEventListener('mouseup', endDragTimer);
        document.addEventListener('touchend', endDragTimer);

        // Initialize Timer
        setRotationTimer(0);
        setProgressTimer(0);
        timerDurationTimer = maxDurationsTimer[currentModeTimer];
        updateCurrentTimeTimer();
        setInterval(updateCurrentTimeTimer, 1000);
    </script>

    <!-- Live Text Copier Scripts -->
    <script>
        // Live Text Copier Functionality
        const textRef = database.ref('sharedText');
        const textArea = document.getElementById('textInput');

        // Google Sign-in with Popup
        document.getElementById('loginButton').addEventListener('click', () => {
            const provider = new firebase.auth.GoogleAuthProvider();
            auth.signInWithPopup(provider)
                .then((result) => {
                    console.log("Bruger logget ind:", result.user.displayName);
                    alert(`Velkommen, ${result.user.displayName}!`);
                })
                .catch((error) => {
                    console.error("Login-fejl:", error.message);
                    alert("Login fejlede: " + error.message);
                });
        });

        // Listen for changes and update the textarea
        textRef.on('value', (snapshot) => {
            const text = snapshot.val();
            textArea.value = text || '';
        });

        // Update the database when the textarea content changes
        textArea.addEventListener('input', () => {
            const value = textArea.value;
            textRef.set(value);
        });

        // Copy text to clipboard
        function copyText() {
            textArea.select();
            document.execCommand('copy');
            document.getElementById('status').innerText = "Tekst kopieret!";
            setTimeout(() => {
                document.getElementById('status').innerText = "";
            }, 2000);
        }

        // Settings Menu Functionality
        const settingsButton = document.getElementById('settingsButton');
        const settingsMenu = document.getElementById('settingsMenu');
        const loginButton = document.getElementById('loginButton');
        const toggleLoginButton = document.getElementById('toggleLoginButton');
        const fullscreenButton = document.getElementById('fullscreenButton');

        // Show/hide settings menu
        settingsButton.addEventListener('click', () => {
            settingsMenu.classList.toggle('active');
        });

        // Show/hide login button
        toggleLoginButton.addEventListener('click', () => {
            if (loginButton.style.display === 'none') {
                loginButton.style.display = 'block';
                toggleLoginButton.textContent = 'Skjul Log ind';
            } else {
                loginButton.style.display = 'none';
                toggleLoginButton.textContent = 'Vis Log ind';
            }
        });

        // Fullscreen functionality
        fullscreenButton.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });
    </script>

    <!-- Navigation Script -->
    <script>
        const btnCalendar = document.getElementById('btn-calendar');
        const btnTimer = document.getElementById('btn-timer');
        const btnTextCopier = document.getElementById('btn-text-copier');
        const calendarView = document.getElementById('calendar-view');
        const timerView = document.getElementById('timer-view');
        const textCopierView = document.getElementById('text-copier-view');
        const navButtons = document.querySelectorAll('.nav-button');

        btnCalendar.addEventListener('click', () => {
            showView('calendar');
        });

        btnTimer.addEventListener('click', () => {
            showView('timer');
        });

        btnTextCopier.addEventListener('click', () => {
            showView('text-copier');
        });

        function showView(view) {
            if (view === 'calendar') {
                calendarView.classList.add('active-view');
                timerView.classList.remove('active-view');
                textCopierView.classList.remove('active-view');
                btnCalendar.classList.add('active');
                btnTimer.classList.remove('active');
                btnTextCopier.classList.remove('active');
            } else if (view === 'timer') {
                timerView.classList.add('active-view');
                calendarView.classList.remove('active-view');
                textCopierView.classList.remove('active-view');
                btnTimer.classList.add('active');
                btnCalendar.classList.remove('active');
                btnTextCopier.classList.remove('active');
            } else if (view === 'text-copier') {
                textCopierView.classList.add('active-view');
                calendarView.classList.remove('active-view');
                timerView.classList.remove('active-view');
                btnTextCopier.classList.add('active');
                btnCalendar.classList.remove('active');
                btnTimer.classList.remove('active');
            }
        }
    </script>
</body>
</html>
