´<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Home</title>
    <style>
        /* Common Styles */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e7eb 100%);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .hidden {
            display: none;
        }

        /* Navigation Button Styles */
        .nav-button-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 100;
        }

        .nav-dot {
            width: 12px;
            height: 12px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .nav-dot.active {
            background: rgba(255, 255, 255, 1);
        }

        /* Calendar Styles */
        .calendar-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            padding-bottom: 60px; /* Space for navigation button */
            transition: opacity 0.5s ease;
        }

        /* Timer Styles */
        .timer-container {
            flex: 1;
            display: none; /* Hidden by default */
            justify-content: center;
            align-items: center;
            position: relative;
            padding-bottom: 60px; /* Space for navigation button */
            transition: opacity 0.5s ease;
        }

        /* Include all your existing Calendar and Timer CSS here */
        /* Calendar CSS */
        .calendar-inner {
            position: relative;
            width: 80%;
            max-width: 600px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            display: flex;
            flex-direction: column;
            align-items: center;
            border-radius: 20px;
            color: rgba(0, 0, 0, 0.8);
        }

        /* Timer CSS */
        .timer-inner {
            position: relative;
            width: 300px;
            height: 300px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.15);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* Responsive adjustments */
        @media (max-width: 480px) {
            .calendar-inner, .timer-inner {
                width: 90%;
                padding: 15px;
            }
            /* Adjust Timer size */
            .timer-inner {
                width: 250px;
                height: 250px;
            }
        }
    </style>
</head>
<body>

    <!-- Calendar Section -->
    <div class="calendar-container" id="calendar-section">
        <div class="calendar-inner">
            <div id="header">
                <div id="date-container">
                    <div id="date"></div>
                    <div id="month-name"></div>
                </div>
                <div id="day-name"></div>
                <!-- Fullscreen Button -->
                <button class="fullscreen-button" id="fullscreen-btn" aria-label="Toggle Fullscreen"></button>
            </div>
            <div id="editor" contenteditable="true"></div>
            <!-- New Box for Avatar and Text Bubble -->
            <div class="avatar-box" onclick="openChat()">
                <div class="avatar">
                    <img src="Avatar.jpeg" alt="Avatar">
                </div>
                <div class="text-bubble" id="greeting-message">
                    <!-- Placeholder for text bubble content -->
                </div>
            </div>
        </div>
    </div>

    <!-- Timer Section -->
    <div class="timer-container" id="timer-section">
        <div class="timer-inner">
            <svg class="progress-ring" viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="45" />
                <circle class="progress" cx="50" cy="50" r="45" />
            </svg>
            <canvas class="connecting-circle" width="300" height="300"></canvas>
            <div class="mode-indicators">
                <div class="mode-indicator" style="top: 15%; left: 50%;"></div>
                <div class="mode-indicator" style="top: 50%; right: 15%;"></div>
                <div class="mode-indicator" style="bottom: 15%; left: 50%;"></div>
            </div>
            <div class="knob"></div>
            <div class="display">--:--</div>
            <div class="mode-name"></div>
        </div>
    </div>

    <!-- Navigation Buttons -->
    <div class="nav-button-container">
        <div class="nav-dot active" id="nav-calendar" title="Calendar"></div>
        <div class="nav-dot" id="nav-timer" title="Timer"></div>
    </div>

    <!-- Sound Effects for Calendar -->
    <audio id="calendar-hover-sound" src="Hover.wav" preload="auto"></audio>
    <audio id="calendar-click-sound" src="click.mp3" preload="auto"></audio>

    <!-- Sound Effects for Timer -->
    <audio id="timer-hover-sound" src="Hover.wav" preload="auto"></audio>
    <audio id="timer-click-sound" src="click.mp3" preload="auto"></audio>
    <audio id="alarm-sound" src="1.mp3" preload="auto"></audio>

    <script>
        /* === Navigation Logic === */
        const calendarSection = document.getElementById('calendar-section');
        const timerSection = document.getElementById('timer-section');
        const navCalendar = document.getElementById('nav-calendar');
        const navTimer = document.getElementById('nav-timer');

        function showCalendar() {
            calendarSection.style.display = 'flex';
            timerSection.style.display = 'none';
            navCalendar.classList.add('active');
            navTimer.classList.remove('active');
        }

        function showTimer() {
            calendarSection.style.display = 'none';
            timerSection.style.display = 'flex';
            navTimer.classList.add('active');
            navCalendar.classList.remove('active');
        }

        navCalendar.addEventListener('click', showCalendar);
        navTimer.addEventListener('click', showTimer);

        /* === Calendar JavaScript === */
        (function() {
            const editor = document.getElementById('editor');
            const dayNameElement = document.getElementById('day-name');
            const dateElement = document.getElementById('date');
            const monthNameElement = document.getElementById('month-name');
            const greetingMessageElement = document.getElementById('greeting-message');

            const fullscreenBtn = document.getElementById('fullscreen-btn');
            const header = document.getElementById('header');

            const hoverSound = document.getElementById('calendar-hover-sound');
            const clickSound = document.getElementById('calendar-click-sound');

            let longPressTimer;
            const longPressDuration = 500; // milliseconds

            // Function to enter fullscreen
            function enterFullscreen() {
                const elem = document.documentElement;
                if (elem.requestFullscreen) {
                    elem.requestFullscreen();
                } else if (elem.webkitRequestFullscreen) { /* Safari */
                    elem.webkitRequestFullscreen();
                } else if (elem.msRequestFullscreen) { /* IE11 */
                    elem.msRequestFullscreen();
                }
            }

            // Function to exit fullscreen
            function exitFullscreen() {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) { /* Safari */
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) { /* IE11 */
                    document.msExitFullscreen();
                }
            }

            // Toggle fullscreen mode
            function toggleFullscreen() {
                if (!document.fullscreenElement && !document.webkitFullscreenElement && !document.msFullscreenElement) {
                    enterFullscreen();
                } else {
                    exitFullscreen();
                }
            }

            // Show fullscreen button
            function showFullscreenButton() {
                fullscreenBtn.classList.add('visible');
            }

            // Hide fullscreen button
            function hideFullscreenButton() {
                fullscreenBtn.classList.remove('visible');
            }

            // Event listeners for long press on header
            header.addEventListener('touchstart', (e) => {
                // Start the timer
                longPressTimer = setTimeout(() => {
                    showFullscreenButton();
                }, longPressDuration);
            });

            header.addEventListener('touchend', (e) => {
                // Clear the timer
                clearTimeout(longPressTimer);
            });

            header.addEventListener('touchmove', (e) => {
                // If user moves finger, cancel the long press
                clearTimeout(longPressTimer);
            });

            // Hide fullscreen button when tapping outside
            document.addEventListener('touchstart', (e) => {
                if (!fullscreenBtn.contains(e.target) && !header.contains(e.target)) {
                    hideFullscreenButton();
                }
            });

            // Click event for fullscreen button
            fullscreenBtn.addEventListener('click', () => {
                toggleFullscreen();
                hideFullscreenButton();
            });

            // Existing JavaScript code...

            const danishDays = ['Søndag', 'Mandag', 'Tirsdag', 'Onsdag', 'Torsdag', 'Fredag', 'Lørdag'];
            const danishMonths = ['Januar', 'Februar', 'Marts', 'April', 'Maj', 'Juni', 'Juli', 'August', 'September', 'Oktober', 'November', 'December'];

            const startDate = 3; // October 3
            const startMonth = 9; // October (0-based index)
            const endMonth = 11; // December (0-based index)
            const year = 2024;

            const canvasKeys = [];
            let totalDays = 0;

            for (let month = startMonth; month <= endMonth; month++) {
                const daysInMonth = new Date(year, month + 1, 0).getDate();
                const startDay = month === startMonth ? startDate : 1;
                for (let day = startDay; day <= daysInMonth; day++) {
                    canvasKeys.push(`canvas${year}${(month + 1).toString().padStart(2, '0')}${day.toString().padStart(2, '0')}`);
                    totalDays++;
                }
            }

            let currentCanvasIndex = 0;

            // Load canvases from localStorage or initialize them
            const canvases = canvasKeys.map(key => localStorage.getItem(key) || '');

            // Load messages from messages.json
            let greetings = {
                morning: [],
                afternoon: [],
                evening: []
            };
            let congratulatoryMessages = [];

            fetch('messages.json')
                .then(response => response.json())
                .then(data => {
                    greetings = data.greetings;
                    congratulatoryMessages = data.congratulations;
                    // After loading messages, set the initial greeting
                    selectGreeting();
                })
                .catch(error => {
                    console.error('Error fetching messages:', error);
                    // Fallback greeting messages in case of error
                    greetings.morning = [
                        "Morning, Mr. M! How about we kick things off with today’s game plan?",
                        "Good morning, Mr. M! Let’s set our sights on a productive day!"
                    ];
                    greetings.afternoon = [
                        "Good afternoon, Mr. M! How’s the day going? Ready to map out what's next?",
                        "Hey Mr. M! Let’s take a quick look at the afternoon's plan."
                    ];
                    greetings.evening = [
                        "Good evening, Mr. M! Shall we go over the day's accomplishments?",
                        "Hey Mr. M! Let’s recap and prep for tomorrow!"
                    ];
                    selectGreeting();
                });

            function updateEditor() {
                let currentDay = startDate;
                let currentMonth = startMonth;
                for (let i = 0; i < currentCanvasIndex; i++) {
                    currentDay++;
                    if (currentDay > new Date(year, currentMonth + 1, 0).getDate()) {
                        currentDay = 1;
                        currentMonth++;
                    }
                }
                const date = new Date(year, currentMonth, currentDay);
                dayNameElement.innerText = danishDays[date.getDay()];
                dateElement.innerText = currentDay;
                monthNameElement.innerText = danishMonths[currentMonth];
                editor.innerHTML = canvases[currentCanvasIndex];
            }

            function saveCurrentCanvas() {
                canvases[currentCanvasIndex] = editor.innerHTML;
                localStorage.setItem(canvasKeys[currentCanvasIndex], editor.innerHTML);
            }

            function translateText(text) {
                // Adjusted translation to avoid interfering with '.'
                return text
                    .replace(/;/g, 'æ')
                    .replace(/'/g, 'ø')
                    .replace(/\[/g, 'å');
                    // Removed the regex that replaces two digits with a dot
            }

            function setCurrentCanvasIndex() {
                const today = new Date();
                if (today >= new Date(year, startMonth, startDate) && today <= new Date(year, endMonth + 1, 0)) {
                    const daysSinceStart = Math.floor((today - new Date(year, startMonth, startDate)) / (1000 * 60 * 60 * 24));
                    currentCanvasIndex = Math.min(daysSinceStart, totalDays - 1);
                } else {
                    currentCanvasIndex = 0;
                }
            }

            function showPreviousCanvas() {
                saveCurrentCanvas();
                currentCanvasIndex = (currentCanvasIndex === 0) ? canvases.length - 1 : currentCanvasIndex - 1;
                hoverSound.play();
                updateEditor();
            }

            function showNextCanvas() {
                saveCurrentCanvas();
                currentCanvasIndex = (currentCanvasIndex === canvases.length - 1) ? 0 : currentCanvasIndex + 1;
                hoverSound.play();
                updateEditor();
            }

            let messageTimeout; // To track the message display timeout

            function handleClick(event) {
                if (event.target.classList.contains('clickable')) {
                    // Toggle the 'completed' class
                    if (event.target.classList.contains('completed')) {
                        event.target.classList.remove('completed');
                    } else {
                        event.target.classList.add('completed');
                        clickSound.play();

                        // Display a random congratulatory message
                        displayCongratulatoryMessage();
                    }
                    // Save the updated content after toggling
                    saveCurrentCanvas();
                }
            }

            function openChat() {
                window.open('https://huggingface.co/chat/', '_blank');
            }

            // Function to select and display the appropriate greeting based on time of day
            function selectGreeting() {
                const now = new Date();
                const hours = now.getHours();
                let message = "";

                if (hours >= 5 && hours < 12) { // Morning: 5 AM - 12 PM
                    message = getRandomMessage(greetings.morning);
                } else if (hours >= 12 && hours < 18) { // Afternoon: 12 PM - 6 PM
                    message = getRandomMessage(greetings.afternoon);
                } else { // Evening: 6 PM - 5 AM
                    message = getRandomMessage(greetings.evening);
                }

                greetingMessageElement.innerText = message;
                greetingMessageElement.classList.remove('hidden'); // Ensure it's visible
            }

            // Helper function to get a random message from a given array
            function getRandomMessage(messageArray) {
                if (messageArray.length === 0) return "";
                const randomIndex = Math.floor(Math.random() * messageArray.length);
                return messageArray[randomIndex];
            }

            // Function to display a congratulatory message
            function displayCongratulatoryMessage() {
                if (congratulatoryMessages.length === 0) return; // Ensure messages are loaded

                // Select a random message
                const randomIndex = Math.floor(Math.random() * congratulatoryMessages.length);
                const message = congratulatoryMessages[randomIndex];
                const fullMessage = `${message.icon} ${message.text}`;

                // Clear any existing timeout to prevent multiple messages overlapping
                if (messageTimeout) {
                    clearTimeout(messageTimeout);
                    messageTimeout = null;
                }

                // Set the congratulatory message
                greetingMessageElement.innerText = fullMessage;

                // Remove 'hidden' class to trigger fade-in
                greetingMessageElement.classList.remove('hidden');

                // After 20 seconds, fade out and revert to greeting
                messageTimeout = setTimeout(() => {
                    // Add 'hidden' class to trigger fade-out
                    greetingMessageElement.classList.add('hidden');

                    // After fade-out transition (0.5s), revert to default greeting
                    setTimeout(() => {
                        selectGreeting();
                    }, 500); // Match the CSS transition duration
                }, 20000); // 20 seconds
            }

            // New Function: Handle conversion when '.' is typed
            function handleDotConversion() {
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                const range = selection.getRangeAt(0);
                const node = range.startContainer;

                // Ensure we're dealing with a text node
                if (node.nodeType !== Node.TEXT_NODE) return;
                const text = node.textContent;
                const dotIndex = text.lastIndexOf('.');

                // If a '.' is found at the end of the text
                if (dotIndex === text.length - 1) {
                    const beforeDot = text.slice(0, dotIndex).trim();

                    if (beforeDot.length === 0) return; // Avoid empty lines

                    // Replace the text node with a clickable span
                    const span = document.createElement('span');
                    span.classList.add('clickable');
                    span.textContent = beforeDot;

                    // Replace the text node with the span
                    node.parentNode.replaceChild(span, node);

                    // Insert a line break after the span
                    const br = document.createElement('br');
                    span.parentNode.insertBefore(br, span.nextSibling);

                    // Move the cursor to the new line after the line break
                    const newRange = document.createRange();
                    newRange.setStartAfter(br);
                    newRange.collapse(true);

                    // Update the selection to the new range
                    selection.removeAllRanges();
                    selection.addRange(newRange);

                    // Save the updated content
                    saveCurrentCanvas();
                }
            }

            // New Keyup Event Listener for Immediate '.' Detection
            editor.addEventListener('keyup', (e) => {
                if (e.key === '.') {
                    handleDotConversion();
                }
            });

            // Optional: Handle paste events to ensure '.' detection
            editor.addEventListener('paste', (e) => {
                // Delay execution to allow the paste to complete
                setTimeout(() => {
                    handleDotConversion();
                }, 0);
            });

            // Modified input event listener
            editor.addEventListener('input', () => {
                // Immediate processing without delay

                const translatedText = translateText(editor.innerText);
                if (translatedText !== editor.innerText) {
                    const selection = window.getSelection();
                    if (selection.rangeCount > 0) {
                        const range = selection.getRangeAt(0);
                        const cursorPosition = range.startOffset;
                        editor.innerText = translatedText;
                        const newRange = document.createRange();
                        newRange.setStart(editor.firstChild, cursorPosition);
                        newRange.collapse(true);
                        selection.removeAllRanges();
                        selection.addRange(newRange);
                    }
                }

                // Save the current canvas
                saveCurrentCanvas();

                // No delayed conversion needed
            });

            // Event listeners for navigation and clicks
            dateElement.addEventListener('click', showPreviousCanvas);
            dayNameElement.addEventListener('click', showNextCanvas);
            editor.addEventListener('click', handleClick);

            // Keyboard navigation
            document.addEventListener('keydown', (e) => {
                if (e.key === 'ArrowLeft') {
                    showPreviousCanvas();
                } else if (e.key === 'ArrowRight') {
                    showNextCanvas();
                }
            });

            setCurrentCanvasIndex();
            updateEditor();
            // Greeting is set after messages are fetched
        })();

        /* === Timer JavaScript === */
        (function() {
            const knob = timerSection.querySelector('.knob');
            const display = timerSection.querySelector('.display');
            const modeName = timerSection.querySelector('.mode-name');
            const progressRing = timerSection.querySelector('.progress');
            const modeIndicators = timerSection.querySelectorAll('.mode-indicator');
            const container = timerSection.querySelector('.timer-inner');
            const canvas = timerSection.querySelector('.connecting-circle');
            const ctx = canvas.getContext('2d');

            // Sound effects
            const hoverSound = document.getElementById('timer-hover-sound');
            const clickSound = document.getElementById('timer-click-sound');
            const alarmSound = document.getElementById('alarm-sound');

            let angle = 0;
            let isDragging = false;
            let startAngle = 0;
            let currentMode = 0;
            let timerDuration = 0;
            let timerInterval;
            let modeChangeTimeout;
            let animationFrame;
            let isKnobMoved = false;
            let audioUnlocked = false;

            const modes = ['Pomodoro', 'Break', 'SoMe'];
            const maxDurations = [25 * 60, 5 * 60, 7 * 60]; // in seconds

            function setRotation(degrees) {
                knob.style.transform = `rotate(${degrees}deg) translate(120px) rotate(-${degrees}deg)`;
            }

            function setProgress(percent) {
                const circumference = 2 * Math.PI * 45;
                const offset = circumference - (percent / 100) * circumference;
                progressRing.style.strokeDasharray = `${circumference} ${circumference}`;
                progressRing.style.strokeDashoffset = offset;
            }

            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }

            function updateTimer() {
                timerDuration--;
                if (timerDuration <= 0) {
                    clearInterval(timerInterval);
                    cancelAnimationFrame(animationFrame);
                    playAlarm();
                    return;
                }
                display.textContent = formatTime(timerDuration);
                setProgress((1 - timerDuration / maxDurations[currentMode]) * 100);
            }

            function startTimer() {
                clearInterval(timerInterval);
                cancelAnimationFrame(animationFrame);
                timerDuration = maxDurations[currentMode];
                display.textContent = formatTime(timerDuration);
                setProgress(0);
                timerInterval = setInterval(updateTimer, 1000);
                animateConnectingCircle();

                // Play the click sound when the timer starts
                clickSound.play();
            }

            function playAlarm() {
                let alarmCount = 0;
                const maxAlarms = 5;

                function playAlarmSound() {
                    if (alarmCount < maxAlarms) {
                        const playPromise = alarmSound.play();
                        if (playPromise !== undefined) {
                            playPromise.then(() => {
                                alarmCount++;
                                // Wait for the duration of the alarm sound before playing again
                                setTimeout(playAlarmSound, alarmSound.duration * 1000);
                            }).catch(error => {
                                console.error('Failed to play alarm sound:', error);
                            });
                        } else {
                            // Fallback if play() is undefined
                            alarmCount++;
                            setTimeout(playAlarmSound, 1000);
                        }
                    } else {
                        // After playing the alarm 5 times, reset to show the current time
                        updateCurrentTime();
                        isKnobMoved = false; // Reset to show time mode
                    }
                }

                playAlarmSound();
            }

            function showModeName() {
                modeName.textContent = modes[currentMode];
                modeName.style.opacity = '1';
                display.style.opacity = '0';
            }

            function hideModeName() {
                modeName.style.opacity = '0';
                display.style.opacity = '1';
            }

            function updateCurrentTime() {
                if (!isKnobMoved) {
                    const now = new Date();
                    const hours = now.getHours().toString().padStart(2, '0');
                    const minutes = now.getMinutes().toString().padStart(2, '0');
                    display.textContent = `${hours}:${minutes}`;
                }
            }

            function unlockAudio() {
                if (!audioUnlocked) {
                    // Attempt to play a silent audio to unlock the audio context
                    const silentAudio = new Audio();
                    silentAudio.muted = true;
                    const playPromise = silentAudio.play();
                    if (playPromise !== undefined) {
                        playPromise.then(() => {
                            audioUnlocked = true;
                            silentAudio.pause();
                            silentAudio.src = '';
                        }).catch(error => {
                            console.warn('Audio unlock failed:', error);
                        });
                    }
                }
            }

            function startDrag(e) {
                isDragging = true;
                isKnobMoved = true;
                const rect = container.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                startAngle = Math.atan2(clientY - centerY, clientX - centerX);
                clearTimeout(modeChangeTimeout);

                // Play hover sound when starting to drag the knob
                hoverSound.play();

                // Unlock audio on first user interaction
                unlockAudio();
            }

            function drag(e) {
                if (!isDragging) return;
                const rect = container.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const currentAngleRad = Math.atan2(clientY - centerY, clientX - centerX);
                let deltaAngle = (currentAngleRad - startAngle) * (180 / Math.PI);
                // Adjust deltaAngle to ensure smooth rotation
                if (deltaAngle > 180) deltaAngle -= 360;
                if (deltaAngle < -180) deltaAngle += 360;
                angle += deltaAngle;
                angle = (angle + 360) % 360;
                setRotation(angle);
                startAngle = currentAngleRad;

                const newMode = Math.floor(angle / 120) % modes.length;
                if (newMode !== currentMode) {
                    currentMode = newMode;
                    modeIndicators.forEach((indicator, index) => {
                        indicator.classList.toggle('active', index === currentMode);
                    });
                    showModeName();
                    timerDuration = maxDurations[currentMode];
                    display.textContent = formatTime(timerDuration);
                    setProgress(0);
                }
            }

            function endDrag() {
                if (isDragging) {
                    isDragging = false;
                    modeChangeTimeout = setTimeout(() => {
                        hideModeName();
                        startTimer();
                    }, 2000);

                    // Play click sound only if the knob was being dragged
                    clickSound.play();
                }
            }

            function animateConnectingCircle() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                
                const time = Date.now() * 0.0005;
                const radius = 135;
                
                ctx.beginPath();
                for (let i = 0; i < 36; i++) {
                    const angleDeg = i * 10;
                    const angleRad = angleDeg * Math.PI / 180;
                    const x = radius * Math.cos(angleRad);
                    const y = radius * Math.sin(angleRad);
                    const nextAngleRad = angleRad + time * 1.44;
                    const nextX = radius * Math.cos(nextAngleRad);
                    const nextY = radius * Math.sin(nextAngleRad);
                    
                    ctx.moveTo(x, y);
                    ctx.lineTo(nextX, nextY);
                    
                    ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 + 0.2 * Math.sin(time + i * 0.2)})`;
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
                
                ctx.restore();
                
                animationFrame = requestAnimationFrame(animateConnectingCircle);
            }

            // Event listeners
            container.addEventListener('mousedown', startDrag);
            container.addEventListener('touchstart', startDrag);

            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag);

            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);

            // Initialize
            setRotation(0);
            setProgress(0);
            timerDuration = maxDurations[currentMode];
            updateCurrentTime();
            setInterval(updateCurrentTime, 1000);
        })();
    </script>
</body>
</html>
